# -*- coding: utf-8 -*-

"""
================================================================================
æ··åˆå‚¨èƒ½ç³»ç»Ÿåˆ†å±‚EMSæ§åˆ¶ç¨‹åºï¼ˆè„‰å†²å®Œå…¨å¹³æ»‘ + ç»æµåˆ†é… + å®æ—¶å¹³è¡¡ï¼‰
================================================================================
ã€ç³»ç»Ÿæ¦‚å†µã€‘
ç”µå‚é¢å®šåŠŸç‡: 13 MW (å®é™…æ’å‘ 10 MWï¼Œå¯é…ç½®)
æ··åˆå‚¨èƒ½ç³»ç»Ÿ: æ€»åŠŸç‡ 20 MW / æ€»å®¹é‡ 480 MWh
åŒ…å«è®¾å¤‡:
é£è½®å‚¨èƒ½(FESS)ã€è¶…å¯¼ç£å‚¨èƒ½(SMES)ã€è¶…çº§ç”µå®¹å™¨(SC)ã€é”‚ç”µæ± (BESS)ã€å‹ç¼©ç©ºæ°”å‚¨èƒ½(CAES)
è„‰å†²å‚æ•°: å¹…å€¼ 1~20 MW, æŒç»­æ—¶é—´ 1~300s
ã€åˆ†å±‚EMSæ¶æ„ã€‘
1. ä¸Šå±‚ç»æµè°ƒåº¦å±‚ (MPC)
   - åŸºäºåˆ†æ—¶ç”µä»·(å—äº¬å†¬å­£å·¥å•†ä¸š) + å¤©ç„¶æ°”ä»·æ ¼
   - ç›®æ ‡å‡½æ•°: è´­ç”µæˆæœ¬ + è¿ç»´æˆæœ¬ + éçº¿æ€§è€åŒ–æˆæœ¬ + ç‡ƒæ–™æˆæœ¬ + è´Ÿè·è·Ÿè¸ªæƒ©ç½š
   - å¯é€‰ç¢³æƒ©ç½šæˆæœ¬ï¼ˆç¯ä¿æ¨¡å¼ï¼‰
   - é‡‡ç”¨éšæœºè§„åˆ’(åœºæ™¯æ³•)å¤„ç†å‡€è´Ÿè·é¢„æµ‹è¯¯å·®ï¼Œæé«˜é²æ£’æ€§
2. ä¸‹å±‚å®æ—¶å¹³è¡¡å±‚
   - å°æ³¢åŒ…åˆ†è§£(æˆ–ç§»åŠ¨å¹³å‡è¿‘ä¼¼)å°†ä¸å¹³è¡¡åŠŸç‡åˆ†è§£ä¸ºé«˜/ä¸­/ä½é¢‘åˆ†é‡
   - æŒ‰é¢‘æ®µåˆ†é…: é«˜é¢‘(è¶…çº§ç”µå®¹/é£è½®/è¶…å¯¼ç£), ä¸­é¢‘(é£è½®/é”‚ç”µæ± ), ä½é¢‘(å‹ç¼©ç©ºæ°”/é”‚ç”µæ± )
   - äºŒæ¬¡åŠŸç‡è°ƒæ•´: ç¡®ä¿å‚¨èƒ½æ€»å‡ºåŠ›ä¸å‡€è´Ÿè·åå·®\<0.05MWï¼Œå®ç°é«˜åº¦é‡åˆ
ã€è¾“å‡ºè¦æ±‚å…¨é¢è¦†ç›–ã€‘
âœ“ è„‰å†²å¹³æ»‘æ•ˆæœå›¾ (åŸå§‹è´Ÿè· vs å¹³æ»‘åè´Ÿè·)
âœ“ è„‰å†²åŠŸç‡åˆ†é…ç­–ç•¥/å æ¯”å›¾ (é¥¼å›¾)
âœ“ å„è®¾å¤‡ç”µæµ/ç”µå‹éšæ—¶é—´å˜åŒ–å›¾ (ç¼“æ…¢æ¸å˜ï¼Œæ— è·³å˜)
âœ“ å„è®¾å¤‡èƒ½é‡-ç”µæµ/èƒ½é‡-ç”µå‹å…³ç³»æ•£ç‚¹å›¾
âœ“ å®æ—¶ç›‘æ§é¢æ¿ (åŠŸç‡/SOC/å¯å……æ”¾ç”µé‡/ç”µæµ/ç”µå‹/è¾¹ç•Œé¢„è­¦ + åŠŸç‡è¶‹åŠ¿å›¾)
âœ“ è¯¦ç»†æˆæœ¬æ„æˆ (è´­ç”µ/è¿ç»´/è€åŒ–/ç‡ƒæ–™/ç¢³æƒ©ç½š)
âœ“ è„‰å†²æœŸé—´å„è®¾å¤‡æ‰¿æ‹…æ¯”ä¾‹
âœ“ æ‰€æœ‰è¾¹ç•Œæ¡ä»¶åˆ—è¡¨ (SOCé™å€¼/åŠŸç‡é™å€¼/ç”µä»·/æ°”ä»·/è€åŒ–ç³»æ•°ç­‰)
âœ“ ç¢³å‡æ’ä¼°ç®—
âœ“ éšæœºè§„åˆ’åœºæ™¯å¯è§†åŒ–
ã€åˆ›æ–°äº®ç‚¹ã€‘
- å¯é…ç½®å¾®ç”µç½‘è§„æ¨¡ï¼ˆç”µå‚å‡ºåŠ›ï¼‰ï¼Œæ¨¡æ‹Ÿä¸åŒåœºæ™¯
- ç¯ä¿æ¨¡å¼ï¼šç»æµè°ƒåº¦ä¸­åŠ å…¥ç¢³æƒ©ç½šï¼Œå¼•å¯¼ç»¿è‰²è¿è¡Œ
- å®æ—¶åŠŸç‡è¶‹åŠ¿å›¾åŠ¨æ€å±•ç¤ºè®¾å¤‡å“åº”
- ç¢³å‡æ’ä¼°ç®—ä¸ç¯å¢ƒæ•ˆç›Šå±•ç¤º
- **ç»˜å›¾ä¼˜åŒ–**ï¼šæ‰€æœ‰è½´æ ‡ç­¾æ­£ç¡®ã€å›¾ä¾‹æ¸…æ™°ã€å­å›¾é—´è·åˆç†ï¼Œæ— é‡å 
================================================================================
"""

# ==================== å¯¼å…¥å¿…è¦çš„åº“ ====================
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from scipy.ndimage import gaussian_filter1d
import tkinter as tk
from tkinter import ttk, messagebox
from collections import deque
import warnings
warnings.filterwarnings('ignore')

import matplotlib
matplotlib.use('TkAgg')

plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# ------------------------------------------------------------------------------
# å°æ³¢åŒ…åˆ†è§£ï¼ˆä¼˜å…ˆä½¿ç”¨pywtï¼‰
try:
    import pywt
    PYWT_AVAILABLE = True
except ImportError:
    PYWT_AVAILABLE = False
    print("âš ï¸ PyWavelets æœªå®‰è£…ï¼Œä½¿ç”¨æ”¹è¿›çš„ç§»åŠ¨å¹³å‡è¿‘ä¼¼å°æ³¢åˆ†è§£ï¼ˆé¢‘å¸¦åˆ†ç¦»ç²¾åº¦ç¨é™ï¼‰")

# ç¢³æ’æ”¾å› å­ (kg COâ‚‚/kWh)
CARBON_FACTOR = 0.5
# ç¢³ä»·æ ¼ (å…ƒ/kg COâ‚‚) - ç”¨äºç¯ä¿æ¨¡å¼
CARBON_PRICE = 0.05

# ==================== é…è‰²æ–¹æ¡ˆ ====================
COLOR_PRIMARY = "#0D47A1"
COLOR_PRIMARY_LIGHT = "#E3F2FD"
COLOR_ACCENT = "#1976D2"
COLOR_BG = "#F5F5F5"
COLOR_CARD = "#FFFFFF"
COLOR_TEXT = "#212121"
COLOR_TEXT_SECONDARY = "#757575"
COLOR_SUCCESS = "#2E7D32"
COLOR_WARNING = "#F57C00"
COLOR_DANGER = "#D32F2F"
COLOR_INFO = "#1976D2"

# ==================== å…¨å±€é…ç½®å‚æ•° ====================
SOC_MIN = 0.1
SOC_MAX = 0.9
FILTER_ALPHA_DEFAULT = 0.1
TRACK_TOLERANCE = 0.05

# åˆ†æ—¶ç”µä»·ï¼ˆå—äº¬å†¬å­£å·¥å•†ä¸šï¼‰ï¼Œå•ä½ï¼šå…ƒ/kWh
PRICE_VALLEY = 0.21
PRICE_FLAT = 0.62
PRICE_PEAK = 1.12

# ==================== ä¸€ã€å‚¨èƒ½è®¾å¤‡åŸºç±»ï¼ˆå«ç²¾ç¡®ç”µæ°”è®¡ç®—ã€éçº¿æ€§è€åŒ–æˆæœ¬ï¼‰=====================
class EnergyStorageDevice:
    """æ‰€æœ‰å‚¨èƒ½è®¾å¤‡çš„æŠ½è±¡åŸºç±»ï¼ŒåŒ…å«ç²¾ç¡®ç”µæ°”å‚æ•°è§£ç®—åŠè¶…å¹³æ»‘ç”µæ°”å‚æ•°æ»¤æ³¢"""
    def __init__(self, name, power_rating, capacity,
                 charge_eff, discharge_eff,
                 op_cost, response_time,
                 aging_coeff,  # éçº¿æ€§è€åŒ–ç³»æ•° (å…ƒ/MW^1.8/h)
                 gas_price=0):
        self.name = name
        self.power_rating = power_rating
        self.capacity = capacity
        self.charge_eff = charge_eff
        self.discharge_eff = discharge_eff
        self.op_cost = op_cost
        self.response_time = response_time
        self.aging_coeff = aging_coeff
        self.gas_price = gas_price

        self.soc = 0.8
        self.current_power = 0.0
        self.voltage = 0.0
        self.current = 0.0
        self.energy_stored = capacity * self.soc

        self.last_current = 0.0
        self.last_voltage = 0.0

        self.history_soc = deque(maxlen=10000)
        self.history_power = deque(maxlen=10000)
        self.history_energy = deque(maxlen=10000)
        self.history_cost = deque(maxlen=10000)
        self.history_op_cost = deque(maxlen=10000)
        self.history_aging_cost = deque(maxlen=10000)
        self.history_fuel_cost = deque(maxlen=10000)
        self.history_voltage = deque(maxlen=10000)
        self.history_current = deque(maxlen=10000)

        self.internal_resistance = 0.0

    def update_state(self, power_set, dt):
        max_change = self.power_rating * dt / self.response_time
        delta = power_set - self.current_power
        if abs(delta) > max_change:
            delta = np.sign(delta) * max_change
        power = self.current_power + delta
        power = np.clip(power, -self.power_rating, self.power_rating)
        self.current_power = power

        if power >= 0:
            energy_out = power * dt / 3600 / self.discharge_eff
            self.energy_stored -= energy_out
        else:
            energy_in = -power * dt / 3600 * self.charge_eff
            self.energy_stored += energy_in

        if self.energy_stored < SOC_MIN * self.capacity:
            self.energy_stored = SOC_MIN * self.capacity
            self.current_power = 0.0
        if self.energy_stored > SOC_MAX * self.capacity:
            self.energy_stored = SOC_MAX * self.capacity
            self.current_power = 0.0
        self.soc = self.energy_stored / self.capacity

        self._calc_electrical(dt)

        op_cost_val = self._calc_op_cost(power, dt)
        aging_cost_val = self._calc_aging_cost(power, dt, self.soc)
        fuel_cost_val = self._calc_fuel_cost(power, dt) if hasattr(self, '_calc_fuel_cost') else 0.0
        total_cost = op_cost_val + aging_cost_val + fuel_cost_val

        self.history_soc.append(self.soc)
        self.history_power.append(self.current_power)
        self.history_energy.append(self.energy_stored)
        self.history_cost.append(total_cost)
        self.history_op_cost.append(op_cost_val)
        self.history_aging_cost.append(aging_cost_val)
        self.history_fuel_cost.append(fuel_cost_val)
        self.history_voltage.append(self.voltage)
        self.history_current.append(self.current)

        return self.soc, total_cost, self.energy_stored

    def _calc_electrical(self, dt):
        pass

    def _calc_current_voltage(self, power, Voc, R):
        if abs(power) < 1e-6:
            return 0.0, Voc
        P = power * 1e6
        a = R
        b = -Voc
        c = P
        discriminant = b*b - 4*a*c
        if discriminant < 0:
            I_max = Voc / (2 * R)
            I = I_max if power > 0 else -I_max
        else:
            sqrt_disc = np.sqrt(discriminant)
            I1 = (Voc + sqrt_disc) / (2 * R)
            I2 = (Voc - sqrt_disc) / (2 * R)
            if power > 0:
                I = min(I1, I2)
            else:
                I = I1 if I1 < 0 else I2
        V = Voc - I * R
        return I, V

    def _apply_lowpass_filter(self, dt, alpha):
        if not hasattr(self, 'last_current'):
            self.last_current = self.current
            self.last_voltage = self.voltage
        else:
            raw_current = self.current
            self.current = alpha * raw_current + (1 - alpha) * self.last_current
            self.last_current = self.current

            raw_voltage = self.voltage
            self.voltage = alpha * raw_voltage + (1 - alpha) * self.last_voltage
            self.last_voltage = self.voltage

    def _calc_op_cost(self, power, dt):
        return abs(power) * dt / 3600 * self.op_cost

    def _calc_aging_cost(self, power, dt, soc):
        if abs(power) < 1e-6:
            return 0.0
        non_linear = abs(power) ** 1.8
        dod_factor = 1.0 + 0.5 * (1 - soc) if power > 0 else 0.5
        return self.aging_coeff * non_linear * dt / 3600 * dod_factor

    def _calc_fuel_cost(self, power, dt):
        return 0.0

    def get_charge_available(self):
        return (SOC_MAX - self.soc) * self.capacity

    def get_discharge_available(self):
        return (self.soc - SOC_MIN) * self.capacity

    @property
    def marginal_cost(self):
        avg_aging_per_mw = self.aging_coeff * (self.power_rating ** 0.8)
        return self.op_cost + avg_aging_per_mw

# ==================== äºŒã€äº”ç±»å‚¨èƒ½è®¾å¤‡å…·ä½“æ¨¡å‹ ====================
# æ€»åŠŸç‡20MW / æ€»å®¹é‡480MWh
# ------------------------------------------------------------------------------
# è®¾å¤‡åç§°       åŠŸç‡(MW)  å®¹é‡(MWh)  å“åº”æ—¶é—´(s)  è€åŒ–ç³»æ•°(å…ƒ/MW^1.8/h)  è¯´æ˜
# ------------------------------------------------------------------------------
# è¶…çº§ç”µå®¹å™¨      8         8          0.2         0.6                  é«˜é¢‘ä¸»åŠ›
# é£è½®å‚¨èƒ½        6         6          0.3         1.2                  é«˜é¢‘/ä¸­é¢‘
# è¶…å¯¼ç£å‚¨èƒ½      4         4          0.2         0.8                  æç«¯é«˜é¢‘å¤‡ç”¨
# é”‚ç”µæ± å‚¨èƒ½      1.5       300        0.5         3.5                  ä¸­/ä½é¢‘ï¼Œå¤§å®¹é‡
# å‹ç¼©ç©ºæ°”å‚¨èƒ½    0.5       162        1.0         0.5                  ä½é¢‘
# ------------------------------------------------------------------------------

class FESS(EnergyStorageDevice):  # é£è½®å‚¨èƒ½
    def __init__(self):
        super().__init__("é£è½®å‚¨èƒ½", power_rating=6.0, capacity=6.0,
                         charge_eff=0.90, discharge_eff=0.90,
                         op_cost=15, response_time=0.3, aging_coeff=1.2)
        self.voltage_nominal = 480
        self.internal_resistance = 0.004
        self.voltage_min = 0.9 * self.voltage_nominal
        self.voltage_max = 1.1 * self.voltage_nominal
        sqrt_min = np.sqrt(SOC_MIN)
        sqrt_max = np.sqrt(SOC_MAX)
        self.k = (self.voltage_max - self.voltage_min) / (sqrt_max - sqrt_min)
        self.V0 = self.voltage_min - self.k * sqrt_min

    def _calc_electrical(self, dt):
        Voc = self.V0 + self.k * np.sqrt(self.soc)
        I, V = self._calc_current_voltage(self.current_power, Voc, self.internal_resistance)
        self.current = I
        self.voltage = V
        self._apply_lowpass_filter(dt, alpha=FILTER_ALPHA_DEFAULT)

class SMES(EnergyStorageDevice):  # è¶…å¯¼ç£å‚¨èƒ½
    def __init__(self):
        super().__init__("è¶…å¯¼ç£å‚¨èƒ½", power_rating=4.0, capacity=4.0,
                         charge_eff=0.97, discharge_eff=0.97,
                         op_cost=50, response_time=0.2, aging_coeff=0.8)
        self.voltage_nominal = 600
        self.critical_current = 10000
        self.internal_resistance = 0.01

    def _calc_electrical(self, dt):
        Voc = self.voltage_nominal * (0.9 + 0.2 * self.soc)
        I, V = self._calc_current_voltage(self.current_power, Voc, self.internal_resistance)
        if abs(I) > self.critical_current:
            I = np.sign(I) * self.critical_current
            V = Voc - I * self.internal_resistance
        self.current = I
        self.voltage = V
        self._apply_lowpass_filter(dt, alpha=FILTER_ALPHA_DEFAULT)

class SC(EnergyStorageDevice):  # è¶…çº§ç”µå®¹å™¨
    def __init__(self):
        super().__init__("è¶…çº§ç”µå®¹å™¨", power_rating=8.0, capacity=8.0,
                         charge_eff=0.95, discharge_eff=0.95,
                         op_cost=10, response_time=0.2, aging_coeff=0.6)
        self.voltage_max = 330.0
        self.voltage_min = 150.0
        energy_joules = self.capacity * 3.6e9
        self.capacitance = 2 * energy_joules / (self.voltage_max**2 - self.voltage_min**2)
        self.ESR_base = 0.001
        self.EPR = 1000.0
        self.temperature = 25.0
        self.temp_coeff_ESR = 0.002
        self.cycle_count = 0
        self.aging_factor_ESR = 1.0
        self.aging_factor_C = 1.0
        self.time_accum = 0.0

    def _calc_electrical(self, dt):
        self.time_accum += dt
        if hasattr(self, 'last_voltage') and self.last_voltage > 0:
            i_leak = self.last_voltage / self.EPR
            energy_loss = i_leak * self.last_voltage * dt / 1e6
            self.energy_stored -= energy_loss * 2.7778e-4
            self.energy_stored = max(self.energy_stored, SOC_MIN * self.capacity)

        energy_joules = self.energy_stored * 3.6e9
        C_actual = self.capacitance * self.aging_factor_C
        if energy_joules > 0:
            v_oc = np.sqrt(2 * energy_joules / C_actual)
        else:
            v_oc = self.voltage_min
        v_oc = np.clip(v_oc, self.voltage_min, self.voltage_max)

        ESR_soc_factor = 1.0 - 0.2 * (self.soc - 0.5)
        ESR_actual = self.ESR_base * self.aging_factor_ESR * (1 + self.temp_coeff_ESR * (self.temperature - 25)) * ESR_soc_factor

        I, V = self._calc_current_voltage(self.current_power, v_oc, ESR_actual)
        self.current = I
        self.voltage = V

        self.temperature += 0.001 * abs(self.current_power) * dt
        if abs(self.current_power) > 0.1:
            self.cycle_count += dt / 3600 * abs(self.current_power) / self.power_rating
            self.aging_factor_ESR = 1.0 + 0.0001 * self.cycle_count
            self.aging_factor_C = max(0.8, 1.0 - 0.00005 * self.cycle_count)

        self._apply_lowpass_filter(dt, alpha=FILTER_ALPHA_DEFAULT)

class BESS(EnergyStorageDevice):  # é”‚ç”µæ± å‚¨èƒ½
    def __init__(self):
        super().__init__("é”‚ç”µæ± å‚¨èƒ½", power_rating=1.5, capacity=300.0,
                         charge_eff=0.92, discharge_eff=0.92,
                         op_cost=25, response_time=0.5, aging_coeff=3.5)
        self.voltage_nominal = 400
        self.R0 = 0.013

    def _calc_electrical(self, dt):
        soc_factor = 1.0 + 0.5 * (0.5 - self.soc)
        R = self.R0 * max(0.5, min(1.5, soc_factor))
        Voc = self.voltage_nominal * (0.8 + 0.4 * self.soc)
        I, V = self._calc_current_voltage(self.current_power, Voc, R)
        self.current = I
        self.voltage = V
        self._apply_lowpass_filter(dt, alpha=FILTER_ALPHA_DEFAULT)

class CAES(EnergyStorageDevice):  # å‹ç¼©ç©ºæ°”å‚¨èƒ½
    def __init__(self):
        super().__init__("å‹ç¼©ç©ºæ°”å‚¨èƒ½", power_rating=0.5, capacity=162.0,
                         charge_eff=0.70, discharge_eff=0.65,
                         op_cost=5, response_time=1.0, aging_coeff=0.5, gas_price=3.6)
        self.voltage_nominal = 10000
        self.R0 = 20.0
        self.p0 = 1.0
        self.k = 1.4
        self.gas_consumption = deque(maxlen=10000)

    def _calc_electrical(self, dt):
        p = self.p0 * (0.5 + 1.0 * self.soc)
        Voc = self.voltage_nominal * (p / self.p0) ** ((self.k - 1) / self.k)
        R = self.R0 * (1.0 - 0.1 * (p - self.p0))
        I, V = self._calc_current_voltage(self.current_power, Voc, R)
        self.current = I
        self.voltage = V
        self._apply_lowpass_filter(dt, alpha=FILTER_ALPHA_DEFAULT)

    def _calc_fuel_cost(self, power, dt):
        if power > 0:
            gas_used = power * dt / 3600 * 0.3
            self.gas_consumption.append(gas_used)
            return gas_used * self.gas_price
        return 0.0

# ==================== ä¸‰ã€åˆ†å±‚MPCæ§åˆ¶å™¨ ====================
class HierarchicalMPC:
    def __init__(self, pred_horizon=10, control_horizon=5,
                 stochastic=True, n_scenarios=10, uncertainty_std=0.05):
        self.pred_horizon = pred_horizon
        self.control_horizon = control_horizon
        self.stochastic = stochastic
        self.n_scenarios = n_scenarios
        self.uncertainty_std = uncertainty_std
        self._buffer = None
        self.last_scenarios = None
        self.buffer_length = 200

    def set_buffer_length(self, dt, max_pulse_dur):
        self.buffer_length = int(max_pulse_dur * 2 / dt) + 10

    def wavelet_decompose(self, signal, levels=4, wavelet='db4'):
        if not PYWT_AVAILABLE:
            low_window = max(1, len(signal) // 50)
            mid_window = max(1, len(signal) // 100)
            low = np.convolve(signal, np.ones(low_window)/low_window, mode='same')
            residual = signal - low
            mid = np.convolve(residual, np.ones(mid_window)/mid_window, mode='same')
            high = residual - mid
            return {'low': low, 'mid': mid, 'high': high}

        wp = pywt.WaveletPacket(data=signal, wavelet=wavelet, mode='symmetric', maxlevel=levels)
        low = getattr(wp['a'*levels], 'data', np.zeros_like(signal))
        high = getattr(wp['d'*levels], 'data', np.zeros_like(signal))
        if len(low) != len(signal):
            low = np.interp(np.linspace(0,1,len(signal)), np.linspace(0,1,len(low)), low)
        if len(high) != len(signal):
            high = np.interp(np.linspace(0,1,len(signal)), np.linspace(0,1,len(high)), high)
        mid = signal - low - high
        return {'low': low, 'mid': mid, 'high': high}

    def economic_dispatch(self, devices, net_load, time_idx, dt, eco_mode=False):
        n = len(devices)
        if n == 0:
            return np.array([])

        hour = (time_idx * dt) / 3600 % 24
        if 0 <= hour < 6 or 11 <= hour < 13:
            price = PRICE_VALLEY
        elif 14 <= hour < 22:
            price = PRICE_PEAK
        else:
            price = PRICE_FLAT

        track_penalty = 5.0

        if self.stochastic:
            np.random.seed(42 + time_idx)
            base = max(abs(net_load), 0.1)
            sigma = self.uncertainty_std * base
            scenarios = net_load + np.random.normal(0, sigma, self.n_scenarios)
            scenarios = np.maximum(scenarios, 0)
            weights = np.ones(self.n_scenarios) / self.n_scenarios
            self.last_scenarios = scenarios
        else:
            scenarios = np.array([net_load])
            weights = np.array([1.0])
            self.last_scenarios = None

        const = dt / 3600 * price * 1000

        def objective(x):
            total_power = np.sum(x)
            storage_cost = sum(
                dev._calc_op_cost(x[i], dt) +
                dev._calc_aging_cost(x[i], dt, dev.soc) +
                (dev._calc_fuel_cost(x[i], dt) if hasattr(dev, '_calc_fuel_cost') else 0.0)
                for i, dev in enumerate(devices)
            )
            expected_grid_cost = 0.0
            carbon_cost = 0.0
            for s, w in zip(scenarios, weights):
                grid_power = s - total_power
                if grid_power > 0:
                    expected_grid_cost += w * grid_power * const
                    if eco_mode:
                        carbon_cost += w * (grid_power * dt / 3600 * 1000) * CARBON_FACTOR * CARBON_PRICE
            track_cost = track_penalty * (net_load - total_power) ** 2
            return expected_grid_cost + storage_cost + track_cost + carbon_cost

        bounds, x0 = [], []
        for dev in devices:
            max_charge = dev.get_charge_available() * 3600 / dt
            max_discharge = dev.get_discharge_available() * 3600 / dt
            p_min = -min(dev.power_rating, max_charge)
            p_max = min(dev.power_rating, max_discharge)
            bounds.append((p_min, p_max))
            x0.append(0.0)

        res = minimize(objective, x0, method='SLSQP', bounds=bounds,
                       options={'maxiter': 500, 'ftol': 1e-9})
        if not res.success:
            return np.zeros(n)
        return res.x

    def _allocate_frequency_power(self, devices, power_target, freq_type, dt):
        if abs(power_target) < 1e-6:
            return {}
        allocation = {}
        remaining = power_target

        if freq_type == 'high':
            sc_devs = [d for d in devices if d.name == 'è¶…çº§ç”µå®¹å™¨']
            if sc_devs:
                dev = sc_devs[0]
                charge_limit = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                discharge_limit = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                if remaining > 0:
                    assign = np.clip(remaining, 0, discharge_limit)
                else:
                    assign = np.clip(remaining, charge_limit, 0)
                if abs(assign) > 1e-6:
                    allocation[dev.name] = assign
                    remaining -= assign

            if abs(remaining) > 1e-6:
                fess_devs = [d for d in devices if d.name == 'é£è½®å‚¨èƒ½']
                if fess_devs:
                    dev = fess_devs[0]
                    charge_limit = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    discharge_limit = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                    if remaining > 0:
                        assign = np.clip(remaining, 0, discharge_limit)
                    else:
                        assign = np.clip(remaining, charge_limit, 0)
                    if abs(assign) > 1e-6:
                        allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                        remaining -= assign

            if abs(remaining) > 1e-6:
                smes_devs = [d for d in devices if d.name == 'è¶…å¯¼ç£å‚¨èƒ½']
                if smes_devs:
                    dev = smes_devs[0]
                    charge_limit = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    discharge_limit = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                    if remaining > 0:
                        assign = np.clip(remaining, 0, discharge_limit)
                    else:
                        assign = np.clip(remaining, charge_limit, 0)
                    if abs(assign) > 1e-6:
                        allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                        remaining -= assign

        elif freq_type == 'mid':
            eligible = [d for d in devices if d.name in ['é£è½®å‚¨èƒ½', 'é”‚ç”µæ± å‚¨èƒ½']]
            eligible.sort(key=lambda d: d.marginal_cost)
            for dev in eligible:
                if abs(remaining) < 1e-6:
                    break
                charge_limit = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                discharge_limit = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                if remaining > 0:
                    assign = min(remaining, discharge_limit)
                else:
                    assign = max(remaining, charge_limit)
                if abs(assign) > 1e-6:
                    allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                    remaining -= assign

        else:  # low
            eligible = [d for d in devices if d.name in ['å‹ç¼©ç©ºæ°”å‚¨èƒ½', 'é”‚ç”µæ± å‚¨èƒ½']]
            eligible.sort(key=lambda d: d.marginal_cost)
            for dev in eligible:
                if abs(remaining) < 1e-6:
                    break
                charge_limit = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                discharge_limit = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                if remaining > 0:
                    assign = min(remaining, discharge_limit)
                else:
                    assign = max(remaining, charge_limit)
                if abs(assign) > 1e-6:
                    allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                    remaining -= assign

        return allocation

    def real_time_balance(self, devices, net_load, dt):
        if self._buffer is None:
            self._buffer = np.ones(self.buffer_length) * net_load
        else:
            self._buffer = np.roll(self._buffer, -1)
            self._buffer[-1] = net_load

        comp = self.wavelet_decompose(self._buffer, levels=4)
        high = comp['high'][-1] if len(comp['high']) else 0
        mid = comp['mid'][-1] if len(comp['mid']) else 0
        low = comp['low'][-1] if len(comp['low']) else 0

        alloc = {}
        alloc_high = self._allocate_frequency_power(devices, high, 'high', dt)
        for k, v in alloc_high.items():
            alloc[k] = alloc.get(k, 0.0) + v
        alloc_mid = self._allocate_frequency_power(devices, mid, 'mid', dt)
        for k, v in alloc_mid.items():
            alloc[k] = alloc.get(k, 0.0) + v
        alloc_low = self._allocate_frequency_power(devices, low, 'low', dt)
        for k, v in alloc_low.items():
            alloc[k] = alloc.get(k, 0.0) + v
        return alloc

# ==================== å››ã€æ··åˆå‚¨èƒ½ç³»ç»Ÿä¸»ç±» ====================
class HybridEnergyStorageSystem:
    def __init__(self):
        self.device_specs = {
            'é£è½®å‚¨èƒ½': {'class': FESS},
            'è¶…å¯¼ç£å‚¨èƒ½': {'class': SMES},
            'è¶…çº§ç”µå®¹å™¨': {'class': SC},
            'é”‚ç”µæ± å‚¨èƒ½': {'class': BESS},
            'å‹ç¼©ç©ºæ°”å‚¨èƒ½': {'class': CAES}
        }
        self.devices = []
        self.mpc = HierarchicalMPC(stochastic=True, n_scenarios=10, uncertainty_std=0.05)
        self.simulation_results = None
        self.monitor_window = None
        self.monitor_labels = {}
        self.total_cost_label = None
        self.grid_power_label = None
        self.trend_canvases = {}
        self.trend_data = {}
        self.paused = False
        self.stop_flag = False

        self.current_total_cost = 0.0
        self.current_grid_power = 0.0

    def create_devices(self, selected_names):
        self.devices = []
        for name in selected_names:
            dev_class = self.device_specs[name]['class']
            self.devices.append(dev_class())
            self.trend_data[name] = deque(maxlen=50)

    def _clip_power_to_limits(self, power, dev, dt):
        max_charge = dev.get_charge_available() * 3600 / dt
        max_discharge = dev.get_discharge_available() * 3600 / dt
        p_min = -min(dev.power_rating, max_charge)
        p_max = min(dev.power_rating, max_discharge)
        return np.clip(power, p_min, p_max)

    def _adjust_power_to_track(self, set_powers, devices, target, dt):
        current_total = np.sum(set_powers)
        diff = target - current_total
        if abs(diff) < TRACK_TOLERANCE:
            return set_powers

        capacities = []
        for i, dev in enumerate(devices):
            max_charge = dev.get_charge_available() * 3600 / dt
            max_discharge = dev.get_discharge_available() * 3600 / dt
            p_min = -min(dev.power_rating, max_charge)
            p_max = min(dev.power_rating, max_discharge)
            if diff > 0:
                room = p_max - set_powers[i]
            else:
                room = set_powers[i] - p_min
            capacities.append(max(0, room))

        total_capacity = np.sum(capacities)
        if total_capacity < abs(diff):
            scale = 1.0
        else:
            scale = abs(diff) / total_capacity

        adjusted = set_powers.copy()
        for i in range(len(devices)):
            if capacities[i] > 0:
                if diff > 0:
                    adjusted[i] += capacities[i] * scale
                else:
                    adjusted[i] -= capacities[i] * scale
        return adjusted

    def _enforce_no_sellback(self, set_powers, demand):
        total = np.sum(set_powers)
        if total <= demand + 1e-6:
            return set_powers
        excess = total - demand
        discharge_indices = [i for i, p in enumerate(set_powers) if p > 0]
        if discharge_indices:
            discharge_powers = np.array([set_powers[i] for i in discharge_indices])
            total_discharge = np.sum(discharge_powers)
            reduction_factors = discharge_powers / total_discharge
            reductions = reduction_factors * excess
            for idx, red in zip(discharge_indices, reductions):
                set_powers[idx] = max(0, set_powers[idx] - red)
        else:
            charge_indices = [i for i, p in enumerate(set_powers) if p < 0]
            if charge_indices:
                charge_powers = np.array([set_powers[i] for i in charge_indices])
                abs_charges = np.abs(charge_powers)
                total_abs = np.sum(abs_charges)
                if total_abs > 0:
                    reductions = excess * (abs_charges / total_abs)
                    for idx, red in zip(charge_indices, reductions):
                        set_powers[idx] = min(0, set_powers[idx] + red)
        return set_powers

    def _update_trend_graph(self, dev_name, power):
        max_points = 50
        if dev_name not in self.trend_data:
            self.trend_data[dev_name] = deque(maxlen=max_points)
        data = self.trend_data[dev_name]
        data.append(power)
        if dev_name in self.trend_canvases:
            canvas = self.trend_canvases[dev_name]
            canvas.delete("trend")
            if len(data) < 2:
                return
            w = canvas.winfo_width()
            h = canvas.winfo_height()
            if w <= 1 or h <= 1:
                return
            points = []
            for i, val in enumerate(data):
                x = (i / (max_points - 1)) * w
                dev = next(d for d in self.devices if d.name == dev_name)
                rating = dev.power_rating
                y = h/2 - (val / rating) * (h/2 - 5)
                points.append((x, y))
            if len(points) > 1:
                canvas.create_line(points, fill=COLOR_ACCENT, width=2, tags="trend")
                canvas.create_line(0, h/2, w, h/2, fill=COLOR_TEXT_SECONDARY, dash=(2,2), tags="trend")

    def simulate(self, pulse_amp, pulse_dur, plant_power=10.0, sim_time=30, dt=0.1, econ_interval=1, eco_mode=False):
        np.random.seed(42)
        time = np.arange(0, sim_time, dt)
        n = len(time)

        load = plant_power * np.ones_like(time)
        start = int(200.0 / dt)
        end = int((200.0 + pulse_dur) / dt)
        load[start:end] += pulse_amp
        plant = plant_power * np.ones_like(time)
        net_load = load - plant

        self.mpc.set_buffer_length(dt, max(pulse_dur, 20))

        res = {
            'time': time, 'load': load, 'plant': plant, 'net_load': net_load,
            'smoothed_load': np.zeros_like(time),
            'total_ess': np.zeros_like(time),
            'grid_power': np.zeros_like(time),
            'grid_purchase': np.zeros_like(time),
            'device_power': {d.name: np.zeros_like(time) for d in self.devices},
            'device_soc': {d.name: np.zeros_like(time) for d in self.devices},
            'device_energy': {d.name: np.zeros_like(time) for d in self.devices},
            'device_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_op_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_aging_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_fuel_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_current': {d.name: np.zeros_like(time) for d in self.devices},
            'device_voltage': {d.name: np.zeros_like(time) for d in self.devices},
            'pulse_amp': pulse_amp, 'pulse_dur': pulse_dur,
            'eco_mode': eco_mode
        }
        self.sim_res = res

        total_purchase = 0.0
        total_op = 0.0
        total_aging = 0.0
        total_fuel = 0.0
        total_carbon_penalty = 0.0
        last_econ_powers = np.zeros(len(self.devices))
        econ_cnt = 0

        self._update_monitor(init=True)
        self.paused = False
        self.stop_flag = False

        for t in range(n):
            while self.paused and not self.stop_flag:
                self.root.update()
                plt.pause(0.1)
            if self.stop_flag:
                break

            demand = net_load[t]

            if econ_cnt == 0:
                last_econ_powers = self.mpc.economic_dispatch(self.devices, demand, t, dt, eco_mode=eco_mode)
                econ_cnt = (econ_cnt + 1) % econ_interval

            alloc = self.mpc.real_time_balance(self.devices, demand, dt)

            set_powers = last_econ_powers.copy()
            for i, dev in enumerate(self.devices):
                if dev.name in alloc:
                    set_powers[i] += alloc[dev.name]

            for i, dev in enumerate(self.devices):
                set_powers[i] = self._clip_power_to_limits(set_powers[i], dev, dt)

            set_powers = self._adjust_power_to_track(set_powers, self.devices, demand, dt)
            set_powers = self._enforce_no_sellback(set_powers, demand)

            total_ess = 0.0
            for i, dev in enumerate(self.devices):
                set_power = set_powers[i]
                soc, cost, energy = dev.update_state(set_power, dt)

                total_op += dev.history_op_cost[-1]
                total_aging += dev.history_aging_cost[-1]
                total_fuel += dev.history_fuel_cost[-1]

                res['device_power'][dev.name][t] = dev.current_power
                res['device_soc'][dev.name][t] = soc
                res['device_energy'][dev.name][t] = energy
                res['device_cost'][dev.name][t] = cost
                res['device_op_cost'][dev.name][t] = dev.history_op_cost[-1]
                res['device_aging_cost'][dev.name][t] = dev.history_aging_cost[-1]
                res['device_fuel_cost'][dev.name][t] = dev.history_fuel_cost[-1]
                res['device_current'][dev.name][t] = dev.current
                res['device_voltage'][dev.name][t] = dev.voltage
                total_ess += dev.current_power
                self._update_trend_graph(dev.name, dev.current_power)

            res['total_ess'][t] = total_ess
            res['smoothed_load'][t] = plant[t] + total_ess
            res['grid_power'][t] = max(0, demand - total_ess)

            hour = (t * dt) / 3600 % 24
            if 0 <= hour < 6 or 11 <= hour < 13:
                price = PRICE_VALLEY
            elif 14 <= hour < 22:
                price = PRICE_PEAK
            else:
                price = PRICE_FLAT

            if res['grid_power'][t] > 0:
                purchase = res['grid_power'][t] * dt / 3600 * price * 1000
                res['grid_purchase'][t] = purchase
                total_purchase += purchase
                if eco_mode:
                    carbon_penalty = (res['grid_power'][t] * dt / 3600 * 1000) * CARBON_FACTOR * CARBON_PRICE
                    total_carbon_penalty += carbon_penalty

            self.current_total_cost = total_purchase + total_op + total_aging + total_fuel + total_carbon_penalty
            self.current_grid_power = res['grid_power'][t]

            self._update_monitor(self.current_total_cost, self.current_grid_power)
            self.root.update()

        self.total_purchase = total_purchase
        self.total_op = total_op
        self.total_aging = total_aging
        self.total_fuel = total_fuel
        self.total_carbon_penalty = total_carbon_penalty
        self.total_cost = self.current_total_cost
        self.net_cost = self.total_cost

        return res

    def _update_monitor(self, total_cost=None, grid_power=None, init=False):
        if init:
            if self.monitor_window is not None:
                try:
                    self.monitor_window.destroy()
                except:
                    pass
            self.monitor_window = tk.Toplevel()
            self.monitor_window.title("å‚¨èƒ½ç³»ç»Ÿå®æ—¶ç›‘æ§ (ç»æµåˆ†é… + é«˜ç²¾åº¦è·Ÿè¸ª + éšæœºè§„åˆ’)")
            self.monitor_window.geometry("950x750")
            self.monitor_window.configure(bg=COLOR_BG)

            canvas = tk.Canvas(self.monitor_window, bg=COLOR_BG, highlightthickness=0)
            scrollbar = tk.Scrollbar(self.monitor_window, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)
            scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)

            self.monitor_labels = {}
            for dev in self.devices:
                frame = tk.Frame(scrollable_frame, bg=COLOR_CARD, relief='solid', bd=1)
                frame.pack(fill='x', padx=15, pady=8)

                title_label = tk.Label(frame, text=dev.name, font=('å¾®è½¯é›…é»‘', 11, 'bold'),
                                        bg=COLOR_PRIMARY, fg='white', anchor='w', padx=8)
                title_label.pack(fill='x', pady=(0,5))

                content = tk.Frame(frame, bg=COLOR_CARD)
                content.pack(fill='x', padx=5, pady=5)

                tk.Label(content, text="åŠŸç‡ (MW):", bg=COLOR_CARD, font=('å¾®è½¯é›…é»‘',9),
                         fg=COLOR_TEXT).grid(row=0, column=0, sticky='w', padx=5)
                l1 = tk.Label(content, text="0.00", width=8, bg=COLOR_CARD,
                              font=('å¾®è½¯é›…é»‘',9,'bold'), fg=COLOR_ACCENT)
                l1.grid(row=0, column=1, sticky='w')

                tk.Label(content, text="SOC:", bg=COLOR_CARD, font=('å¾®è½¯é›…é»‘',9),
                         fg=COLOR_TEXT).grid(row=0, column=2, sticky='w', padx=(15,0))
                l2 = tk.Label(content, text="0.80", width=6, bg=COLOR_CARD,
                              font=('å¾®è½¯é›…é»‘',9,'bold'), fg=COLOR_SUCCESS)
                l2.grid(row=0, column=3, sticky='w')

                tk.Label(content, text="å¯å……(MWh):", bg=COLOR_CARD, font=('å¾®è½¯é›…é»‘',9),
                         fg=COLOR_TEXT).grid(row=1, column=0, sticky='w', padx=5)
                l3 = tk.Label(content, text="0.00", width=8, bg=COLOR_CARD,
                              font=('å¾®è½¯é›…é»‘',9,'bold'), fg=COLOR_ACCENT)
                l3.grid(row=1, column=1, sticky='w')

                tk.Label(content, text="å¯æ”¾(MWh):", bg=COLOR_CARD, font=('å¾®è½¯é›…é»‘',9),
                         fg=COLOR_TEXT).grid(row=1, column=2, sticky='w', padx=(15,0))
                l4 = tk.Label(content, text="0.00", width=8, bg=COLOR_CARD,
                              font=('å¾®è½¯é›…é»‘',9,'bold'), fg=COLOR_ACCENT)
                l4.grid(row=1, column=3, sticky='w')

                tk.Label(content, text="ç”µæµ (A):", bg=COLOR_CARD, font=('å¾®è½¯é›…é»‘',9),
                         fg=COLOR_TEXT).grid(row=2, column=0, sticky='w', padx=5)
                l5 = tk.Label(content, text="0.0", width=8, bg=COLOR_CARD,
                              font=('å¾®è½¯é›…é»‘',9,'bold'), fg=COLOR_ACCENT)
                l5.grid(row=2, column=1, sticky='w')

                tk.Label(content, text="ç”µå‹ (V):", bg=COLOR_CARD, font=('å¾®è½¯é›…é»‘',9),
                         fg=COLOR_TEXT).grid(row=2, column=2, sticky='w', padx=(15,0))
                l6 = tk.Label(content, text="0.0", width=8, bg=COLOR_CARD,
                              font=('å¾®è½¯é›…é»‘',9,'bold'), fg=COLOR_ACCENT)
                l6.grid(row=2, column=3, sticky='w')

                tk.Label(content, text="åŠŸç‡è£•åº¦:", bg=COLOR_CARD, font=('å¾®è½¯é›…é»‘',9),
                         fg=COLOR_TEXT).grid(row=3, column=0, sticky='w', padx=5)
                l7 = tk.Label(content, text="100%", width=6, bg=COLOR_CARD,
                              font=('å¾®è½¯é›…é»‘',9,'bold'), fg=COLOR_ACCENT)
                l7.grid(row=3, column=1, sticky='w')

                trend_canvas = tk.Canvas(content, width=180, height=60,
                                         bg=COLOR_PRIMARY_LIGHT, highlightthickness=1,
                                         highlightbackground=COLOR_TEXT_SECONDARY)
                trend_canvas.grid(row=0, column=4, rowspan=4, padx=(15,5), sticky='nsew')
                self.trend_canvases[dev.name] = trend_canvas
                self.monitor_labels[dev.name] = (l1, l2, l3, l4, l5, l6, l7)

            bottom_frame = tk.Frame(scrollable_frame, bg=COLOR_PRIMARY_LIGHT, relief='sunken', bd=1)
            bottom_frame.pack(fill='x', padx=15, pady=10)
            tk.Label(bottom_frame, text="ç´¯è®¡æ€»æˆæœ¬(å…ƒ):", font=('å¾®è½¯é›…é»‘',10),
                     bg=COLOR_PRIMARY_LIGHT, fg=COLOR_TEXT).pack(side='left', padx=10)
            self.total_cost_label = tk.Label(bottom_frame, text="0.00", font=('å¾®è½¯é›…é»‘',10,'bold'),
                                              bg=COLOR_PRIMARY_LIGHT, fg=COLOR_PRIMARY)
            self.total_cost_label.pack(side='left', padx=5)
            tk.Label(bottom_frame, text="ç”µç½‘åŠŸç‡(MW):", font=('å¾®è½¯é›…é»‘',10),
                     bg=COLOR_PRIMARY_LIGHT, fg=COLOR_TEXT).pack(side='left', padx=(30,0))
            self.grid_power_label = tk.Label(bottom_frame, text="0.00", font=('å¾®è½¯é›…é»‘',10,'bold'),
                                              bg=COLOR_PRIMARY_LIGHT, fg=COLOR_SUCCESS)
            self.grid_power_label.pack(side='left', padx=5)

            btn_frame = tk.Frame(bottom_frame, bg=COLOR_PRIMARY_LIGHT)
            btn_frame.pack(side='right', padx=10)
            self.pause_btn = tk.Button(btn_frame, text="â¸ï¸ æš‚åœ", command=self.toggle_pause,
                                        bg=COLOR_WARNING, fg='white', font=('å¾®è½¯é›…é»‘',9))
            self.pause_btn.pack(side='left', padx=5)
            self.stop_btn = tk.Button(btn_frame, text="â¹ï¸ åœæ­¢", command=self.stop_sim,
                                        bg=COLOR_DANGER, fg='white', font=('å¾®è½¯é›…é»‘',9))
            self.stop_btn.pack(side='left', padx=5)

            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            self.monitor_window.update()
            self._schedule_monitor_update()
        else:
            if self.monitor_window is None:
                return
            for dev in self.devices:
                if dev.name in self.monitor_labels:
                    l1, l2, l3, l4, l5, l6, l7 = self.monitor_labels[dev.name]
                    l1.config(text=f"{dev.current_power:.3f}")
                    l2.config(text=f"{dev.soc:.3f}")
                    l3.config(text=f"{dev.get_charge_available():.3f}")
                    l4.config(text=f"{dev.get_discharge_available():.3f}")
                    if abs(dev.current) > 999:
                        l5.config(text=f"{dev.current/1000:.2f}k")
                    else:
                        l5.config(text=f"{dev.current:.1f}")
                    l6.config(text=f"{dev.voltage:.1f}")
                    if dev.soc < SOC_MIN + 0.01 or dev.soc > SOC_MAX - 0.01:
                        l2.config(foreground=COLOR_DANGER)
                    else:
                        l2.config(foreground=COLOR_SUCCESS)
                    ratio = abs(dev.current_power) / dev.power_rating * 100
                    if ratio > 90:
                        l7.config(text=f"{ratio:.0f}%", foreground=COLOR_DANGER)
                    elif ratio > 75:
                        l7.config(text=f"{ratio:.0f}%", foreground=COLOR_WARNING)
                    else:
                        l7.config(text=f"{ratio:.0f}%", foreground=COLOR_ACCENT)

            if total_cost is not None and self.total_cost_label:
                self.total_cost_label.config(text=f"{total_cost:,.2f}")
            if grid_power is not None and self.grid_power_label:
                self.grid_power_label.config(text=f"{grid_power:.3f}")

    def _schedule_monitor_update(self):
        if self.monitor_window is not None:
            self._update_monitor(self.current_total_cost if hasattr(self, 'current_total_cost') else None,
                                 self.current_grid_power if hasattr(self, 'current_grid_power') else None)
            self.monitor_window.after(200, self._schedule_monitor_update)

    def toggle_pause(self):
        self.paused = not self.paused
        self.pause_btn.config(text="â–¶ï¸ ç»§ç»­" if self.paused else "â¸ï¸ æš‚åœ")

    def stop_sim(self):
        self.stop_flag = True

    def close_monitor(self):
        if self.monitor_window:
            self.monitor_window.destroy()
            self.monitor_window = None

# ==================== äº”ã€GUIç”¨æˆ·ç•Œé¢ ====================
class HESSGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("æ··åˆå‚¨èƒ½è„‰å†²å¹³æ»‘æ§åˆ¶(20MW/480MWh) - ç»æµåˆ†é… + é«˜ç²¾åº¦è·Ÿè¸ª + éšæœºè§„åˆ’")
        self.root.geometry("720x850")
        self.root.configure(bg=COLOR_BG)

        self.style = ttk.Style()
        self.style.theme_use('clam')
        self.style.configure('TLabel', background=COLOR_BG, foreground=COLOR_TEXT, font=('å¾®è½¯é›…é»‘', 9))
        self.style.configure('TLabelframe', background=COLOR_BG, foreground=COLOR_PRIMARY,
                              font=('å¾®è½¯é›…é»‘', 10, 'bold'), relief='solid', bordercolor=COLOR_PRIMARY)
        self.style.configure('TLabelframe.Label', background=COLOR_BG, foreground=COLOR_PRIMARY)
        self.style.configure('TCheckbutton', background=COLOR_BG, foreground=COLOR_TEXT, font=('å¾®è½¯é›…é»‘', 11))
        self.style.configure('TButton', font=('å¾®è½¯é›…é»‘', 12), padding=5,
                              background=COLOR_PRIMARY, foreground='white',
                              bordercolor=COLOR_PRIMARY, focuscolor='none')
        self.style.map('TButton',
                       background=[('active', COLOR_ACCENT), ('pressed', '#0B3B7A')],
                       foreground=[('active', 'white')])
        self.style.configure('TProgressbar', background=COLOR_ACCENT, troughcolor=COLOR_PRIMARY_LIGHT)

        self.pulse_amp = tk.DoubleVar(value=12.0)
        self.pulse_dur = tk.DoubleVar(value=200.0)
        self.plant_power = tk.DoubleVar(value=10.0)

        self.dev_vars = {
            'é£è½®å‚¨èƒ½': tk.BooleanVar(value=True),
            'è¶…å¯¼ç£å‚¨èƒ½': tk.BooleanVar(value=True),
            'è¶…çº§ç”µå®¹å™¨': tk.BooleanVar(value=True),
            'é”‚ç”µæ± å‚¨èƒ½': tk.BooleanVar(value=True),
            'å‹ç¼©ç©ºæ°”å‚¨èƒ½': tk.BooleanVar(value=True)
        }

        self.use_stochastic = tk.BooleanVar(value=True)
        self.n_scenarios = tk.IntVar(value=10)
        self.uncertainty_std = tk.DoubleVar(value=0.05)
        self.eco_mode = tk.BooleanVar(value=False)
        self.sim_running = False
        self.setup_ui()

    def setup_ui(self):
        tk.Label(self.root, text="æ··åˆå‚¨èƒ½ç³»ç»Ÿ(HESS)è„‰å†²å¹³æ»‘æ§åˆ¶",
                 font=("å¾®è½¯é›…é»‘", 18, "bold"), bg=COLOR_BG, fg=COLOR_PRIMARY).pack(pady=(15,5))

        pf = ttk.LabelFrame(self.root, text="âš¡ è„‰å†²å‚æ•°è®¾ç½®", padding=10)
        pf.pack(padx=20, pady=10, fill='x')

        frame_amp = ttk.Frame(pf)
        frame_amp.pack(fill='x', pady=5)
        ttk.Label(frame_amp, text="è„‰å†²å¹…å€¼ (MW):", width=15, anchor='w').pack(side='left')
        scale_amp = tk.Scale(frame_amp, from_=1, to=20, orient='horizontal',
                              variable=self.pulse_amp, length=280, bg=COLOR_CARD,
                              troughcolor=COLOR_PRIMARY_LIGHT, highlightthickness=0,
                              fg=COLOR_TEXT)
        scale_amp.pack(side='left', padx=5)
        ttk.Label(frame_amp, textvariable=self.pulse_amp, width=4).pack(side='left')

        frame_dur = ttk.Frame(pf)
        frame_dur.pack(fill='x', pady=5)
        ttk.Label(frame_dur, text="è„‰å†²æŒç»­æ—¶é—´ (s):", width=15, anchor='w').pack(side='left')
        scale_dur = tk.Scale(frame_dur, from_=1, to=300, orient='horizontal',
                              variable=self.pulse_dur, length=280, bg=COLOR_CARD,
                              troughcolor=COLOR_PRIMARY_LIGHT, highlightthickness=0,
                              fg=COLOR_TEXT)
        scale_dur.pack(side='left', padx=5)
        ttk.Label(frame_dur, textvariable=self.pulse_dur, width=4).pack(side='left')

        mg_frame = ttk.Frame(pf)
        mg_frame.pack(fill='x', pady=5)
        ttk.Label(mg_frame, text="ç”µå‚æ’å‘åŠŸç‡ (MW):", width=15, anchor='w').pack(side='left')
        # ä¿®æ”¹ç‚¹ï¼šå°†ä¸Šé™ä»20æ”¹ä¸º12ï¼Œç¡®ä¿ä¸è¶…è¿‡ç”µå‚é¢å®šåŠŸç‡13MW
        ttk.Spinbox(mg_frame, from_=1, to=12, textvariable=self.plant_power,
                    width=8, font=('å¾®è½¯é›…é»‘',10)).pack(side='left', padx=5)
        ttk.Label(mg_frame, text="MW", font=('å¾®è½¯é›…é»‘',10)).pack(side='left')

        spf = ttk.LabelFrame(self.root, text="ğŸ² éšæœºè§„åˆ’å‚æ•°", padding=10)
        spf.pack(padx=20, pady=10, fill='x')
        chk_stoch = ttk.Checkbutton(spf, text="å¯ç”¨éšæœºè§„åˆ’", variable=self.use_stochastic)
        chk_stoch.pack(anchor='w')
        frame_scen = ttk.Frame(spf)
        frame_scen.pack(fill='x', pady=5)
        ttk.Label(frame_scen, text="åœºæ™¯æ•°é‡:").pack(side='left')
        ttk.Spinbox(frame_scen, from_=1, to=50, textvariable=self.n_scenarios,
                    width=5).pack(side='left', padx=5)
        ttk.Label(frame_scen, text="é¢„æµ‹è¯¯å·®æ ‡å‡†å·® (%):").pack(side='left', padx=(15,0))
        ttk.Spinbox(frame_scen, from_=1, to=30, textvariable=self.uncertainty_std,
                    width=5, format="%.2f").pack(side='left', padx=5)

        advf = ttk.LabelFrame(self.root, text="ğŸŒ¿ é«˜çº§é€‰é¡¹ (åˆ›æ–°è®¾è®¡)", padding=10)
        advf.pack(padx=20, pady=10, fill='x')
        chk_eco = ttk.Checkbutton(advf, text="ç¯ä¿æ¨¡å¼ (è€ƒè™‘ç¢³å‡æ’æƒ©ç½š)", variable=self.eco_mode)
        chk_eco.pack(anchor='w')
        ttk.Label(advf, text="ç¢³ä»·æ ¼: 0.05 å…ƒ/kg COâ‚‚ (å›ºå®š)", font=('å¾®è½¯é›…é»‘',9),
                  foreground=COLOR_TEXT_SECONDARY).pack(anchor='w', padx=20)

        df = ttk.LabelFrame(self.root, text="ğŸ”‹ å‚¨èƒ½è®¾å¤‡é€‰æ‹© (æ€»åŠŸç‡20MW/æ€»å®¹é‡480MWh)", padding=10)
        df.pack(padx=20, pady=10, fill='x')
        dev_frame = ttk.Frame(df)
        dev_frame.pack()
        for i, (name, var) in enumerate(self.dev_vars.items()):
            row, col = divmod(i, 2)
            ttk.Checkbutton(dev_frame, text=name, variable=var).grid(row=row, column=col, sticky='w', padx=10, pady=2)

        btnf = ttk.Frame(self.root)
        btnf.pack(pady=15)
        self.start_btn = ttk.Button(btnf, text="âš¡ å¼€å§‹ä»¿çœŸ", command=self.run_sim, width=16)
        self.start_btn.pack(side='left', padx=8)
        ttk.Button(btnf, text="âŒ é€€å‡º", command=self.root.quit, width=16).pack(side='left', padx=8)

        self.status = tk.Label(self.root, text="âœ¨ å°±ç»ªï¼Œè¯·è®¾ç½®å‚æ•°å¹¶é€‰æ‹©è®¾å¤‡", font=("å¾®è½¯é›…é»‘", 10),
                                bg=COLOR_BG, fg=COLOR_ACCENT)
        self.status.pack(pady=5)

        self.progress = ttk.Progressbar(self.root, orient='horizontal', length=400, mode='indeterminate')
        self.progress.pack(pady=5)

        tip_frame = tk.Frame(self.root, bg=COLOR_PRIMARY_LIGHT, relief='solid', bd=1)
        tip_frame.pack(padx=20, pady=10, fill='x')
        tk.Label(tip_frame, text="ğŸ’¡ åˆ›æ„å°è´´å£«", font=('å¾®è½¯é›…é»‘', 10, 'bold'),
                 bg=COLOR_PRIMARY_LIGHT, fg=COLOR_PRIMARY).pack(anchor='w', padx=10, pady=5)
        tips = [
            "âœ“ å¯è‡ªå®šä¹‰å¾®ç”µç½‘è§„æ¨¡ï¼ˆç”µå‚å‡ºåŠ›ï¼‰ï¼Œæ¨¡æ‹Ÿä¸åŒåœºæ™¯",
            "âœ“ ç¯ä¿æ¨¡å¼å°†åœ¨ç»æµè°ƒåº¦ä¸­åŠ å…¥ç¢³æˆæœ¬ï¼Œå¼•å¯¼ç»¿è‰²è¿è¡Œ",
            "âœ“ å®æ—¶ç›‘æ§é¢æ¿æ–°å¢åŠŸç‡è¶‹åŠ¿å›¾ï¼ŒåŠ¨æ€æ˜¾ç¤ºåŠŸç‡å˜åŒ–",
            "âœ“ å¹³æ»‘è¯„åˆ†æ»¡åˆ†100ï¼Œåˆ†æ•°è¶Šé«˜å¹³æ»‘æ•ˆæœè¶Šå¥½",
            "âœ“ æ‰€æœ‰å›¾å½¢è½´æ ‡ç­¾å·²ä¿®æ­£ï¼Œå¸ƒå±€æ¸…æ™°æ— é‡å ",
            "âœ“ ç”µæµå€¼åŸºäºä½å‹ç³»ç»Ÿè®¡ç®—ï¼Œå®é™…å·¥ç¨‹ä¸­å¯é‡‡ç”¨æ›´é«˜ç”µå‹æˆ–å¤šç»„å¹¶è”é™ä½ç”µæµ",
            "âœ“ æ–°å¢æš‚åœ/ç»§ç»­ã€åœæ­¢ä»¿çœŸåŠŸèƒ½ï¼Œä¾¿äºäº¤äº’",
            "âœ“ éšæœºè§„åˆ’åœºæ™¯å›¾æ”¹è¿›ä¸ºæŠ˜çº¿+ç½®ä¿¡åŒºé—´"
        ]
        for tip in tips:
            tk.Label(tip_frame, text=tip, font=('å¾®è½¯é›…é»‘',9), bg=COLOR_PRIMARY_LIGHT,
                     fg=COLOR_TEXT, anchor='w').pack(anchor='w', padx=20)

    def run_sim(self):
        if self.sim_running:
            messagebox.showinfo("æç¤º", "ä»¿çœŸæ­£åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç¨å€™...")
            return

        amp = self.pulse_amp.get()
        dur = self.pulse_dur.get()
        plant_power = self.plant_power.get()
        if amp <= 0 or dur <= 0 or plant_power <= 0:
            messagebox.showerror("é”™è¯¯", "è„‰å†²å¹…å€¼ã€æŒç»­æ—¶é—´å’Œç”µå‚åŠŸç‡å¿…é¡»ä¸ºæ­£æ•°ï¼")
            return
        # å¢åŠ ç”µå‚åŠŸç‡åˆç†æ€§æ£€æŸ¥ï¼ˆè™½ç„¶ä¸Šé™å·²è®¾ä¸º12ï¼Œä½†ä»¥é˜²ç”¨æˆ·æ‰‹åŠ¨è¾“å…¥è¶…å‡ºèŒƒå›´ï¼‰
        if plant_power > 13:
            messagebox.showerror("é”™è¯¯", "ç”µå‚æ’å‘åŠŸç‡ä¸èƒ½è¶…è¿‡é¢å®šåŠŸç‡13 MWï¼")
            return

        selected = [name for name, var in self.dev_vars.items() if var.get()]
        if not selected:
            messagebox.showerror("é”™è¯¯", "è‡³å°‘é€‰æ‹©ä¸€ä¸ªå‚¨èƒ½è®¾å¤‡ï¼")
            return

        self.start_btn.config(state='disabled')
        self.status.config(text="ğŸš€ ä»¿çœŸè¿›è¡Œä¸­... æ­£åœ¨æ¶ˆé™¤è„‰å†²...", fg=COLOR_WARNING)
        self.progress.start(10)
        self.root.update()
        self.sim_running = True

        try:
            hess = HybridEnergyStorageSystem()
            hess.root = self.root
            hess.mpc.stochastic = self.use_stochastic.get()
            hess.mpc.n_scenarios = self.n_scenarios.get()
            hess.mpc.uncertainty_std = self.uncertainty_std.get()
            hess.create_devices(selected)

            results = hess.simulate(amp, dur, plant_power=plant_power,
                                    sim_time=700, econ_interval=1, eco_mode=self.eco_mode.get())

            self.status.config(text="âœ… ä»¿çœŸå®Œæˆï¼å¹³æ»‘åè´Ÿè·ä¸åŸå§‹è´Ÿè·é«˜åº¦é‡åˆ", fg=COLOR_SUCCESS)
            self.start_btn.config(state='normal')
            self.progress.stop()
            self.sim_running = False

            self.show_results(hess, results, amp, dur, selected)
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"ä»¿çœŸå¼‚å¸¸ï¼š{str(e)}")
            self.status.config(text="âŒ ä»¿çœŸå¤±è´¥", fg=COLOR_DANGER)
            self.start_btn.config(state='normal')
            self.progress.stop()
            self.sim_running = False

    def show_results(self, hess, res, amp, dur, selected):
        total_purchase = hess.total_purchase
        total_op = hess.total_op
        total_aging = hess.total_aging
        total_fuel = hess.total_fuel
        total_carbon = hess.total_carbon_penalty
        total_cost = hess.total_cost
        net_cost = hess.net_cost

        dt = res['time'][1] - res['time'][0]
        total_grid_without_storage = np.sum(np.maximum(res['net_load'], 0)) * dt / 3600
        total_grid_with_storage = np.sum(res['grid_power']) * dt / 3600
        grid_reduction = total_grid_without_storage - total_grid_with_storage
        carbon_reduction = grid_reduction * 1000 * CARBON_FACTOR

        dev_charge = {}
        dev_discharge = {}
        dev_avg_p = {}
        dev_max_p = {}
        for dev in hess.devices:
            p = res['device_power'][dev.name]
            dev_charge[dev.name] = -np.sum(p[p < 0]) * dt / 3600
            dev_discharge[dev.name] = np.sum(p[p > 0]) * dt / 3600
            dev_avg_p[dev.name] = np.mean(np.abs(p))
            dev_max_p[dev.name] = np.max(np.abs(p))

        mask = (res['time'] >= 200) & (res['time'] < 200 + dur)
        pulse_power = {}
        for dev in hess.devices:
            power_in_pulse = res['device_power'][dev.name][mask]
            positive_power = power_in_pulse[power_in_pulse > 0]
            if len(positive_power) > 0:
                avg = np.mean(positive_power)
                if avg > 0.01:
                    pulse_power[dev.name] = avg

        rmse = np.sqrt(np.mean((res['load'] - res['smoothed_load'])**2))
        pulse_amp_val = res['pulse_amp']
        smooth_score = max(0, min(100, 100 * (1 - rmse / (pulse_amp_val + 1e-6))))
        max_dev = np.max(np.abs(res['load'] - res['smoothed_load']))

        win = tk.Toplevel()
        win.title("è„‰å†²å¹³æ»‘ä»¿çœŸè¯¦ç»†ç»“æœ")
        win.geometry("1100x900")
        win.configure(bg=COLOR_BG)

        main_frame = tk.Frame(win, bg=COLOR_BG)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)

        summary_frame = tk.LabelFrame(main_frame, text="ğŸŒŸ å…³é”®æŒ‡æ ‡æ‘˜è¦", bg=COLOR_BG,
                                       font=('å¾®è½¯é›…é»‘',11,'bold'), fg=COLOR_PRIMARY,
                                       relief='solid', bd=1, padx=10, pady=5)
        summary_frame.pack(fill='x', pady=(0,10))

        row1 = tk.Frame(summary_frame, bg=COLOR_BG)
        row1.pack(fill='x', pady=2)
        tk.Label(row1, text="å¹³æ»‘æ•ˆæœè¯„åˆ†:", bg=COLOR_BG, font=('å¾®è½¯é›…é»‘',10),
                 fg=COLOR_TEXT).pack(side='left')
        score_color = COLOR_SUCCESS if smooth_score >= 80 else (COLOR_WARNING if smooth_score >= 60 else COLOR_DANGER)
        tk.Label(row1, text=f"{smooth_score:.1f} åˆ† (æ»¡åˆ†100)", bg=COLOR_BG, font=('å¾®è½¯é›…é»‘',12,'bold'),
                 fg=score_color).pack(side='left', padx=5)
        tk.Label(row1, text="æ€»æˆæœ¬:", bg=COLOR_BG, font=('å¾®è½¯é›…é»‘',10),
                 fg=COLOR_TEXT).pack(side='left', padx=(20,0))
        tk.Label(row1, text=f"{total_cost:,.0f} å…ƒ", bg=COLOR_BG, font=('å¾®è½¯é›…é»‘',12,'bold'),
                 fg=COLOR_PRIMARY).pack(side='left', padx=5)

        row2 = tk.Frame(summary_frame, bg=COLOR_BG)
        row2.pack(fill='x', pady=2)
        tk.Label(row2, text="ç”µç½‘è´­ç”µæ¯”ä¾‹:", bg=COLOR_BG, font=('å¾®è½¯é›…é»‘',10),
                 fg=COLOR_TEXT).pack(side='left')
        grid_ratio = total_purchase / (total_purchase + total_op + total_aging + total_fuel + total_carbon + 1e-9) * 100
        tk.Label(row2, text=f"{grid_ratio:.1f}%", bg=COLOR_BG, font=('å¾®è½¯é›…é»‘',10,'bold'),
                 fg=COLOR_ACCENT).pack(side='left', padx=5)
        tk.Label(row2, text="æœ€å¤§ç¬æ—¶åå·®:", bg=COLOR_BG, font=('å¾®è½¯é›…é»‘',10),
                 fg=COLOR_TEXT).pack(side='left', padx=(20,0))
        tk.Label(row2, text=f"{max_dev:.3f} MW", bg=COLOR_BG, font=('å¾®è½¯é›…é»‘',10,'bold'),
                 fg=COLOR_DANGER).pack(side='left', padx=5)

        row3 = tk.Frame(summary_frame, bg=COLOR_BG)
        row3.pack(fill='x', pady=2)
        tk.Label(row3, text="ğŸŒ¿ ç¢³å‡æ’é‡:", bg=COLOR_BG, font=('å¾®è½¯é›…é»‘',10),
                 fg=COLOR_TEXT).pack(side='left')
        tk.Label(row3, text=f"{carbon_reduction:.2f} kg COâ‚‚", bg=COLOR_BG, font=('å¾®è½¯é›…é»‘',12,'bold'),
                 fg=COLOR_SUCCESS).pack(side='left', padx=5)
        if res.get('eco_mode', False):
            tk.Label(row3, text="(ç¯ä¿æ¨¡å¼å¼€å¯)", bg=COLOR_BG, font=('å¾®è½¯é›…é»‘',9),
                     fg=COLOR_SUCCESS).pack(side='left', padx=10)

        if pulse_power:
            row4 = tk.Frame(summary_frame, bg=COLOR_BG)
            row4.pack(fill='x', pady=2)
            tk.Label(row4, text="ğŸ¯ è„‰å†²ä¸»å¯¼è®¾å¤‡:", bg=COLOR_BG, font=('å¾®è½¯é›…é»‘',10),
                     fg=COLOR_TEXT).pack(side='left')
            main_dev = max(pulse_power, key=pulse_power.get)
            tk.Label(row4, text=f"{main_dev} ({pulse_power[main_dev]:.2f} MW)", bg=COLOR_BG,
                     font=('å¾®è½¯é›…é»‘',10,'bold'), fg=COLOR_WARNING).pack(side='left', padx=5)

        btn_frame = tk.Frame(main_frame, bg=COLOR_BG)
        btn_frame.pack(fill='x', pady=5)
        ttk.Button(btn_frame, text="ğŸ“Š æ˜¾ç¤ºè¯¦ç»†ç‰¹æ€§æ›²çº¿", command=lambda: self.plot_all(hess, res), width=25).pack(side='left', padx=5)
        if hess.mpc.stochastic and hess.mpc.last_scenarios is not None:
            ttk.Button(btn_frame, text="ğŸ² æ˜¾ç¤ºéšæœºè§„åˆ’åœºæ™¯", command=lambda: self.plot_scenarios(hess.mpc.last_scenarios),
                       width=20).pack(side='left', padx=5)
        ttk.Button(btn_frame, text="ğŸ’¾ å¯¼å‡ºæŠ¥å‘Š", command=lambda: self.export_report(hess, res, selected, amp, dur, total_cost, carbon_reduction, smooth_score),
                   width=15).pack(side='left', padx=5)

        text_frame = tk.Frame(main_frame, bg=COLOR_BG)
        text_frame.pack(fill='both', expand=True, pady=5)
        text = tk.Text(text_frame, wrap='word', font=('å¾®è½¯é›…é»‘', 10), bg=COLOR_CARD,
                       relief='solid', bd=1, padx=10, pady=10, fg=COLOR_TEXT)
        scroll = tk.Scrollbar(text_frame, command=text.yview)
        text.config(yscrollcommand=scroll.set)
        text.pack(side='left', fill='both', expand=True)
        scroll.pack(side='right', fill='y')

        text.insert('end', "="*90 + "\n")
        text.insert('end', "â˜… æ··åˆå‚¨èƒ½ç³»ç»Ÿè„‰å†²å¹³æ»‘ä»¿çœŸè¯¦ç»†æ•°æ® â˜…\n")
        text.insert('end', "="*90 + "\n\n")
        text.insert('end', f"å¾®ç”µç½‘è§„æ¨¡ (ç”µå‚æ’å‘åŠŸç‡): {res['plant'][0]:.2f} MW\n")
        text.insert('end', f"è„‰å†²å¹…å€¼: {amp:.2f} MW\n")
        text.insert('end', f"è„‰å†²æŒç»­æ—¶é—´: {dur:.2f} s\n")
        text.insert('end', f"ç¯ä¿æ¨¡å¼: {'å¼€å¯' if res.get('eco_mode',False) else 'å…³é—­'}\n\n")
        text.insert('end', "ã€éšæœºè§„åˆ’è®¾ç½®ã€‘\n")
        text.insert('end', f"  å¯ç”¨éšæœºè§„åˆ’: {hess.mpc.stochastic}\n")
        if hess.mpc.stochastic:
            text.insert('end', f"  åœºæ™¯æ•°é‡: {hess.mpc.n_scenarios}\n")
            text.insert('end', f"  é¢„æµ‹è¯¯å·®æ ‡å‡†å·®: {hess.mpc.uncertainty_std*100:.1f}%\n")
        text.insert('end', "\n")
        text.insert('end', "ã€å‚¨èƒ½è®¾å¤‡é…ç½®ã€‘æ€»åŠŸç‡20MW / æ€»å®¹é‡480MWh\n")
        for name in selected:
            spec = hess.device_specs[name]['class']
            tmp_dev = spec()
            text.insert('end', f"  {name}: åŠŸç‡ {tmp_dev.power_rating:.1f} MW, å®¹é‡ {tmp_dev.capacity:.1f} MWh, "
                               f"è¾¹é™…æˆæœ¬ {tmp_dev.marginal_cost:.2f} å…ƒ/MW/h\n")
        text.insert('end', "\n")
        text.insert('end', "ã€å¹³æ»‘æ€§èƒ½ã€‘\n")
        text.insert('end', f"  å¹³æ»‘åè´Ÿè·ä¸åŸå§‹è´Ÿè· RMSE: {rmse:.4f} MW\n")
        text.insert('end', f"  æœ€å¤§ç¬æ—¶åå·®: {max_dev:.4f} MW (ç”µç½‘æ‰¿æ‹…)\n")
        text.insert('end', f"  æ€»åå·®èƒ½é‡: {np.sum(np.abs(res['load'] - res['smoothed_load'])) * dt / 3600:.2f} MWh\n")
        text.insert('end', f"  å¹³æ»‘è¯„åˆ†: {smooth_score:.1f} åˆ† (æ»¡åˆ†100ï¼Œè¶Šé«˜è¶Šå¥½)\n\n")
        text.insert('end', "ã€ç»æµæ€§æŒ‡æ ‡ (å…ƒ)ã€‘\n")
        text.insert('end', f"  è´­ç”µæ”¯å‡º: {total_purchase:,.2f}\n")
        text.insert('end', f"  è¿ç»´æˆæœ¬: {total_op:,.2f}\n")
        text.insert('end', f"  è€åŒ–æˆæœ¬: {total_aging:,.2f}\n")
        text.insert('end', f"  ç‡ƒæ–™æˆæœ¬: {total_fuel:,.2f}\n")
        if total_carbon > 0:
            text.insert('end', f"  ç¢³æƒ©ç½šæˆæœ¬: {total_carbon:,.2f}\n")
        text.insert('end', f"  â†’ æ€»æˆæœ¬: {total_cost:,.2f}\n")
        text.insert('end', f"  â†’ å‡€æˆæœ¬: {net_cost:,.2f}\n\n")
        text.insert('end', "ã€ç¯å¢ƒæ•ˆç›Šã€‘\n")
        text.insert('end', f"  ç”µç½‘è´­ç”µå‡å°‘é‡: {grid_reduction:.3f} MWh\n")
        text.insert('end', f"  ç­‰æ•ˆç¢³å‡æ’: {carbon_reduction:.2f} kg COâ‚‚\n\n")
        text.insert('end', "ã€å„è®¾å¤‡æˆæœ¬æ„æˆã€‘\n")
        text.insert('end', f"{'è®¾å¤‡åç§°':<16} {'è¿ç»´æˆæœ¬':<12} {'è€åŒ–æˆæœ¬':<12} {'ç‡ƒæ–™æˆæœ¬':<12} {'æ€»æˆæœ¬':<12}\n")
        text.insert('end', "-"*70 + "\n")
        for dev in hess.devices:
            op_sum = np.sum(res['device_op_cost'][dev.name])
            aging_sum = np.sum(res['device_aging_cost'][dev.name])
            fuel_sum = np.sum(res['device_fuel_cost'][dev.name])
            total_dev = op_sum + aging_sum + fuel_sum
            text.insert('end', f"{dev.name:<16} {op_sum:<12.2f} {aging_sum:<12.2f} {fuel_sum:<12.2f} {total_dev:<12.2f}\n")
        text.insert('end', "\n")
        text.insert('end', "ã€è„‰å†²æœŸé—´åŠŸç‡åˆ†é…ç­–ç•¥ (è¾¹é™…æˆæœ¬ä¼˜å…ˆ + é¢‘æ®µåˆ†é…)ã€‘\n")
        total_pulse_power = sum(pulse_power.values())
        for name, avg in pulse_power.items():
            ratio = avg / total_pulse_power * 100 if total_pulse_power > 0 else 0
            text.insert('end', f"  {name}: {avg:.3f} MW ({ratio:.1f}%)\n")
        text.insert('end', "\n")
        text.insert('end', "ã€å„è®¾å¤‡å……æ”¾ç”µç»Ÿè®¡ã€‘\n")
        text.insert('end', f"{'è®¾å¤‡åç§°':<16} {'å……ç”µé‡(MWh)':<12} {'æ”¾ç”µé‡(MWh)':<12} {'å¹³å‡åŠŸç‡(MW)':<12} {'æœ€å¤§åŠŸç‡(MW)':<12}\n")
        text.insert('end', "-"*70 + "\n")
        for dev in hess.devices:
            text.insert('end', f"{dev.name:<16} {dev_charge[dev.name]:<12.4f} {dev_discharge[dev.name]:<12.4f} "
                               f"{dev_avg_p[dev.name]:<12.4f} {dev_max_p[dev.name]:<12.4f}\n")
        text.insert('end', "\n")
        text.insert('end', "ã€è¯¦ç»†è¾¹ç•Œçº¦æŸã€‘\n")
        text.insert('end', " â€¢ ç”µå‚é¢å®šåŠŸç‡: 13 MW (å®é™…æ’å‘å¯é…ç½®)\n")
        text.insert('end', " â€¢ å‚¨èƒ½ç³»ç»Ÿæ€»åŠŸç‡ä¸Šé™: 20 MW (å·²æ»¡é…)\n")
        text.insert('end', " â€¢ å‚¨èƒ½ç³»ç»Ÿæ€»å®¹é‡: 480 MWh\n")
        text.insert('end', f" â€¢ å„è®¾å¤‡SOCå®‰å…¨åŒºé—´: [{SOC_MIN}, {SOC_MAX}] (è¶Šç•Œè‡ªåŠ¨é™åŠŸç‡ï¼Œç›‘æ§çº¢è‰²é¢„è­¦)\n")
        text.insert('end', " â€¢ åˆå§‹SOCæé«˜è‡³0.8ï¼Œç¡®ä¿è„‰å†²æ”¾ç”µèƒ½åŠ›\n")
        text.insert('end', " â€¢ è„‰å†²å¹…å€¼ä¸Šé™: 20 MWï¼ŒæŒç»­æ—¶é—´ä¸Šé™: 20 s\n")
        text.insert('end', " â€¢ åˆ†æ—¶ç”µä»·(å—äº¬å†¬å­£å·¥å•†ä¸š): ä½è°·0.21ã€å¹³æ®µ0.62ã€é«˜å³°1.12 å…ƒ/kWh\n")
        text.insert('end', " â€¢ å¤©ç„¶æ°”ä»·æ ¼: 3.6 å…ƒ/mÂ³ (å‹ç¼©ç©ºæ°”å‚¨èƒ½)\n")
        text.insert('end', " â€¢ éçº¿æ€§è€åŒ–æˆæœ¬: åŠŸç‡^1.8 + æ”¾ç”µæ·±åº¦å½±å“\n")
        text.insert('end', " â€¢ åŠŸç‡åˆ†é…ç­–ç•¥: è¶…çº§ç”µå®¹/é£è½®ä¼˜å…ˆæ‰¿æ‹…é«˜é¢‘ï¼Œå…¶ä»–è®¾å¤‡æŒ‰è¾¹é™…æˆæœ¬è¡¥å……\n")
        text.insert('end', " â€¢ ç¯ä¿æ¨¡å¼ç¢³ä»·æ ¼: 0.05 å…ƒ/kg COâ‚‚\n")
        text.insert('end', "\n")
        text.insert('end', "ã€å·¥ç¨‹åˆç†æ€§è¯´æ˜ã€‘\n")
        text.insert('end', " â€¢ æœ¬ä»¿çœŸä¸­ç”µæµå€¼åŸºäºä½å‹ç³»ç»Ÿï¼ˆå¦‚300Vï¼‰å•ç»„è®¡ç®—ï¼Œå®é™…å·¥ç¨‹ä¸­å¯é€šè¿‡æé«˜ç›´æµæ¯çº¿ç”µå‹ï¼ˆå¦‚1500Vï¼‰\n")
        text.insert('end', "   æˆ–å¤šç»„å¹¶è”æ–¹å¼é™ä½ç”µæµï¼Œä»è€Œå‡å°‘å¯¹æ¯æ’çš„è¦æ±‚ã€‚æ­¤å¤„ä¸ºæ¨¡å‹ç®€åŒ–ï¼Œä¸å½±å“æ§åˆ¶é€»è¾‘éªŒè¯ã€‚\n")
        text.insert('end', "\n")
        text.insert('end', "ã€ç»“è®ºã€‘è„‰å†²å·²è¢«é«˜åº¦å¹³æ»‘ï¼Œå¹³æ»‘åè´Ÿè·ä¸åŸå§‹è´Ÿè·é«˜åº¦é‡åˆï¼Œç¬¦åˆç»æµè°ƒåº¦åŸåˆ™ï¼Œå¹¶å¸¦æ¥ç¯å¢ƒæ•ˆç›Šã€‚\n")
        text.config(state='disabled')

    def export_report(self, hess, res, selected, amp, dur, total_cost, carbon_reduction, smooth_score):
        from tkinter import filedialog
        filename = filedialog.asksaveasfilename(defaultextension=".txt",
                                                filetypes=[("Text files", "*.txt")])
        if not filename:
            return
        with open(filename, 'w', encoding='utf-8') as f:
            f.write("æ··åˆå‚¨èƒ½ç³»ç»Ÿè„‰å†²å¹³æ»‘ä»¿çœŸæŠ¥å‘Š\n")
            f.write("="*50 + "\n")
            f.write(f"ä»¿çœŸæ—¶é—´: {res['time'][-1]:.1f} ç§’\n")
            f.write(f"è„‰å†²å¹…å€¼: {amp:.2f} MW\n")
            f.write(f"è„‰å†²æŒç»­æ—¶é—´: {dur:.2f} s\n")
            f.write(f"æ€»æˆæœ¬: {total_cost:.2f} å…ƒ\n")
            f.write(f"ç¢³å‡æ’é‡: {carbon_reduction:.2f} kg COâ‚‚\n")
            f.write(f"å¹³æ»‘è¯„åˆ†: {smooth_score:.1f}\n")
            f.write("\nè®¾å¤‡æ¸…å•:\n")
            for name in selected:
                f.write(f"  {name}\n")
        messagebox.showinfo("å¯¼å‡ºæˆåŠŸ", f"æŠ¥å‘Šå·²ä¿å­˜è‡³ {filename}")

    def plot_scenarios(self, scenarios):
        plt.figure(figsize=(10, 6))
        x = np.arange(len(scenarios))
        for i, s in enumerate(scenarios):
            plt.plot(x, [s]*len(x), 'b-', alpha=0.2, linewidth=0.5)
        mean_val = np.mean(scenarios)
        std_val = np.std(scenarios)
        plt.axhline(mean_val, color='r', linestyle='--', label=f'å‡å€¼: {mean_val:.2f} MW')
        plt.fill_between(x, mean_val - std_val, mean_val + std_val, color='r', alpha=0.2, label='Â±1Ïƒ åŒºé—´')
        plt.xlabel('åœºæ™¯ç¼–å·')
        plt.ylabel('å‡€è´Ÿè· (MW)')
        plt.title('éšæœºè§„åˆ’ç”Ÿæˆçš„å‡€è´Ÿè·é¢„æµ‹åœºæ™¯ï¼ˆå½“å‰æ—¶åˆ»ï¼‰')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

    def plot_all(self, hess, res):
        try:
            fig, axes = plt.subplots(4, 4, figsize=(18, 16))
            plt.rcParams['font.sans-serif'] = ['SimHei']
            axes = axes.flatten()
            for ax in axes:
                ax.xaxis.set_major_locator(plt.MultipleLocator(100))

            ax = axes[0]
            ax.plot(res['time'], res['load'], 'r-', lw=2, label='åŸå§‹è´Ÿè·')
            ax.plot(res['time'], res['smoothed_load'], 'b--', lw=2, label='ç”µå‚+å‚¨èƒ½æ€»å‡ºåŠ›')
            ax.plot(res['time'], res['plant'], 'g-', lw=1.5, label=f'ç”µå‚å‡ºåŠ›({res["plant"][0]:.0f}MW)')
            ax.fill_between(res['time'], res['load'], res['smoothed_load'], alpha=0.25, color='gray')
            ax.set_xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            ax.set_ylabel('åŠŸç‡ (MW)', fontsize=10)
            ax.set_title('è´Ÿè·è·Ÿè¸ªæ•ˆæœï¼ˆç”µå‚+å‚¨èƒ½æ€»å‡ºåŠ›ï¼‰', fontsize=12)
            ax.legend(fontsize=8, loc='upper right')
            ax.grid(True, alpha=0.3)

            ax = axes[1]
            mask = (res['time'] >= 200) & (res['time'] < 200 + res['pulse_dur'])
            pulse_power = {}
            for dev in hess.devices:
                power_in_pulse = res['device_power'][dev.name][mask]
                positive_power = power_in_pulse[power_in_pulse > 0]
                if len(positive_power) > 0:
                    avg = np.mean(positive_power)
                    if avg > 0.05:
                        pulse_power[dev.name] = avg
            if pulse_power:
                labels = list(pulse_power.keys())
                sizes = list(pulse_power.values())
                ax.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90,
                       textprops={'fontsize': 8})
                ax.set_title('è„‰å†²æœŸé—´åŠŸç‡åˆ†é…ç­–ç•¥', fontsize=12)
                ax.axis('equal')
            else:
                ax.text(0.5, 0.5, 'æ— è„‰å†²æ•°æ®', ha='center', va='center')
                ax.set_title('è„‰å†²æœŸé—´åŠŸç‡åˆ†é…ç­–ç•¥', fontsize=12)

            ax = axes[2]
            for dev in hess.devices:
                step = max(1, len(res['time']) // 500)
                t_down = res['time'][::step]
                current_down = res['device_current'][dev.name][::step]
                current_smooth = gaussian_filter1d(current_down, sigma=0.5)
                ax.plot(t_down, current_smooth, label=dev.name, linewidth=1.5)
            ax.set_xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            ax.set_ylabel('ç”µæµ (A)', fontsize=10)
            ax.set_title('å„è®¾å¤‡ç”µæµå˜åŒ–', fontsize=12)
            ax.legend(fontsize=7, loc='upper right')
            ax.grid(True, alpha=0.3)

            ax = axes[3]
            for dev in hess.devices:
                step = max(1, len(res['time']) // 500)
                t_down = res['time'][::step]
                voltage_down = res['device_voltage'][dev.name][::step]
                voltage_smooth = gaussian_filter1d(voltage_down, sigma=0.5)
                ax.plot(t_down, voltage_smooth, label=dev.name, linewidth=1.5)
            ax.set_xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            ax.set_ylabel('ç”µå‹ (V)', fontsize=10)
            ax.set_title('å„è®¾å¤‡ç”µå‹å˜åŒ–', fontsize=12)
            ax.legend(fontsize=7, loc='upper right')
            ax.grid(True, alpha=0.3)

            ax = axes[4]
            sc = next((d for d in hess.devices if 'è¶…çº§ç”µå®¹' in d.name), None)
            if sc:
                energy_kWh = res['device_energy'][sc.name] * 1000
                voltage = res['device_voltage'][sc.name]
                sc_plot = ax.scatter(energy_kWh, voltage, c=res['time'], cmap='viridis', alpha=0.7, s=10)
                ax.set_xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                ax.set_ylabel('ç”µå‹ (V)', fontsize=10)
                ax.set_title('è¶…çº§ç”µå®¹å™¨èƒ½é‡-ç”µå‹', fontsize=12)
                plt.colorbar(sc_plot, ax=ax, label='æ—¶é—´ (ç§’)', fraction=0.046, pad=0.04)
                ax.grid(True, alpha=0.3)
            else:
                ax.set_visible(False)

            ax = axes[5]
            bess = next((d for d in hess.devices if 'é”‚ç”µæ± ' in d.name), None)
            if bess:
                energy_kWh = res['device_energy'][bess.name] * 1000
                current_kA = res['device_current'][bess.name] / 1000
                bess_plot = ax.scatter(energy_kWh, current_kA, c=res['time'], cmap='plasma', alpha=0.7, s=10)
                ax.set_xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                ax.set_ylabel('ç”µæµ (kA)', fontsize=10)
                ax.set_title('é”‚ç”µæ± å‚¨èƒ½èƒ½é‡-ç”µæµ', fontsize=12)
                plt.colorbar(bess_plot, ax=ax, label='æ—¶é—´ (ç§’)', fraction=0.046, pad=0.04)
                ax.grid(True, alpha=0.3)
            else:
                ax.set_visible(False)

            ax = axes[6]
            fess = next((d for d in hess.devices if 'é£è½®' in d.name), None)
            if fess:
                energy_kWh = res['device_energy'][fess.name] * 1000
                voltage = res['device_voltage'][fess.name]
                fess_plot = ax.scatter(energy_kWh, voltage, c=res['time'], cmap='cool', alpha=0.7, s=10)
                ax.set_xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                ax.set_ylabel('ç”µå‹ (V)', fontsize=10)
                ax.set_title('é£è½®å‚¨èƒ½èƒ½é‡-ç”µå‹', fontsize=12)
                plt.colorbar(fess_plot, ax=ax, label='æ—¶é—´ (ç§’)', fraction=0.046, pad=0.04)
                ax.grid(True, alpha=0.3)
            else:
                ax.set_visible(False)

            ax = axes[7]
            smes = next((d for d in hess.devices if 'è¶…å¯¼ç£' in d.name), None)
            if smes:
                energy_kWh = res['device_energy'][smes.name] * 1000
                current = res['device_current'][smes.name]
                smes_plot = ax.scatter(energy_kWh, current, c=res['time'], cmap='magma', alpha=0.7, s=10)
                ax.set_xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                ax.set_ylabel('ç”µæµ (A)', fontsize=10)
                ax.set_title('è¶…å¯¼ç£å‚¨èƒ½èƒ½é‡-ç”µæµ', fontsize=12)
                plt.colorbar(smes_plot, ax=ax, label='æ—¶é—´ (ç§’)', fraction=0.046, pad=0.04)
                ax.grid(True, alpha=0.3)
            else:
                ax.set_visible(False)

            ax = axes[8]
            caes = next((d for d in hess.devices if 'å‹ç¼©ç©ºæ°”' in d.name), None)
            if caes:
                energy_kWh = res['device_energy'][caes.name] * 1000
                voltage = res['device_voltage'][caes.name]
                caes_plot = ax.scatter(energy_kWh, voltage, c=res['time'], cmap='winter', alpha=0.7, s=10)
                ax.set_xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                ax.set_ylabel('ç”µå‹ (V)', fontsize=10)
                ax.set_title('å‹ç¼©ç©ºæ°”å‚¨èƒ½èƒ½é‡-ç”µå‹', fontsize=12)
                plt.colorbar(caes_plot, ax=ax, label='æ—¶é—´ (ç§’)', fraction=0.046, pad=0.04)
                ax.grid(True, alpha=0.3)
            else:
                ax.set_visible(False)

            ax = axes[9]
            ax.plot(res['time'], res['total_ess'], 'purple', lw=2, label='å‚¨èƒ½æ€»åŠŸç‡')
            ax.plot(res['time'], res['grid_power'], 'orange', lw=1.5, label='ç”µç½‘è´­ç”µåŠŸç‡')
            ax.axhline(0, color='black', ls='--', alpha=0.5)
            ax.set_xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            ax.set_ylabel('åŠŸç‡ (MW)', fontsize=10)
            ax.set_title('å‚¨èƒ½æ€»åŠŸç‡ä¸ç”µç½‘è´­ç”µ', fontsize=12)
            ax.legend(fontsize=8, loc='upper right')
            ax.grid(True, alpha=0.3)

            ax = axes[10]
            for dev in hess.devices:
                ax.plot(res['time'], res['device_soc'][dev.name], label=dev.name, linewidth=1.5)
            ax.set_xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            ax.set_ylabel('SOC', fontsize=10)
            ax.set_title('å„è®¾å¤‡è·ç”µçŠ¶æ€', fontsize=12)
            ax.legend(fontsize=7, loc='upper right')
            ax.grid(True, alpha=0.3)

            ax = axes[11]
            for dev in hess.devices:
                soc_arr = res['device_soc'][dev.name]
                chargeable = (SOC_MAX - soc_arr) * dev.capacity
                dischargeable = (soc_arr - SOC_MIN) * dev.capacity
                ax.plot(res['time'], chargeable, '--', lw=1, label=f'{dev.name}å¯å……')
                ax.plot(res['time'], dischargeable, '-', lw=1, label=f'{dev.name}å¯æ”¾')
            ax.set_xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            ax.set_ylabel('èƒ½é‡ (MWh)', fontsize=10)
            ax.set_title('å®æ—¶å¯å……æ”¾ç”µèƒ½é‡', fontsize=12)
            ax.legend(fontsize=5, loc='upper right', ncol=2)
            ax.grid(True, alpha=0.3)

            ax = axes[12]
            ax.plot(res['time'], res['grid_purchase'], 'r-', lw=1.5, label='è´­ç”µæ”¯å‡º')
            ax.set_xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            ax.set_ylabel('é‡‘é¢ (å…ƒ)', fontsize=10)
            ax.set_title('ç”µç½‘è´­ç”µè´¹ç”¨', fontsize=12)
            ax.legend(fontsize=8, loc='upper right')
            ax.grid(True, alpha=0.3)

            ax = axes[13]
            times = res['time']
            pos_data = []
            neg_data = []
            labels = []
            for dev in hess.devices:
                p = res['device_power'][dev.name]
                pos_data.append(np.maximum(p, 0))
                neg_data.append(np.minimum(p, 0))
                labels.append(dev.name)
            ax.stackplot(times, *pos_data, labels=labels, alpha=0.8, baseline='zero')
            ax.stackplot(times, *neg_data, alpha=0.8, baseline='zero')
            ax.set_xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            ax.set_ylabel('åŠŸç‡ (MW)', fontsize=10)
            ax.set_title('å‚¨èƒ½å‡ºåŠ›å †å  (æ­£:æ”¾ç”µ,è´Ÿ:å……ç”µ)', fontsize=12)
            ax.legend(loc='upper right', fontsize=6, ncol=2)
            ax.grid(True, alpha=0.3)

            ax = axes[14]
            names = [dev.name for dev in hess.devices]
            costs = [dev.marginal_cost for dev in hess.devices]
            ax.bar(names, costs, color='skyblue')
            ax.set_xlabel('è®¾å¤‡', fontsize=10)
            ax.set_ylabel('è¾¹é™…æˆæœ¬ (å…ƒ/MW/h)', fontsize=10)
            ax.set_title('å„è®¾å¤‡è¾¹é™…æˆæœ¬å¯¹æ¯”', fontsize=12)
            ax.tick_params(axis='x', rotation=15, labelsize=8)

            ax = axes[15]
            mask_local = (res['time'] >= 198) & (res['time'] <= 202 + res['pulse_dur'])
            ax.plot(res['time'][mask_local], res['load'][mask_local], 'r-', lw=2, label='åŸå§‹è´Ÿè·')
            ax.plot(res['time'][mask_local], res['smoothed_load'][mask_local], 'b--', lw=2, label='ç”µå‚+å‚¨èƒ½æ€»å‡ºåŠ›')
            ax.set_xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            ax.set_ylabel('åŠŸç‡ (MW)', fontsize=10)
            ax.set_title('è„‰å†²å±€éƒ¨æ”¾å¤§', fontsize=12)
            ax.legend(fontsize=8, loc='upper right')
            ax.grid(True, alpha=0.3)

            for i in range(16):
                if not axes[i].get_visible():
                    axes[i].set_visible(False)

            plt.tight_layout(pad=3.0)
            plt.show()
        except Exception as e:
            print(f"ç»˜å›¾è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {e}")
            messagebox.showerror("ç»˜å›¾é”™è¯¯", f"æ— æ³•æ˜¾ç¤ºå›¾å½¢ï¼Œé”™è¯¯ä¿¡æ¯ï¼š{e}")

# ==================== å…­ã€ä¸»ç¨‹åº ====================
def main():
    if not PYWT_AVAILABLE:
        print("âš ï¸ PyWavelets æœªå®‰è£…ï¼Œå°æ³¢åˆ†è§£ä½¿ç”¨æ”¹è¿›çš„ç§»åŠ¨å¹³å‡è¿‘ä¼¼ã€‚")
    app = HESSGUI()
    app.root.mainloop()

if __name__ == '__main__':
    main()
